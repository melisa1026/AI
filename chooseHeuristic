from __future__ import annotations
import argparse
import copy
from datetime import datetime
from enum import Enum
from dataclasses import dataclass, field
from time import sleep
from typing import Tuple, TypeVar, Type, Iterable, ClassVar, Dict
import random
import requests
import json

# maximum and minimum values for our heuristic scores (usually represents an end of game condition)
MAX_HEURISTIC_SCORE = 2000000000
MIN_HEURISTIC_SCORE = -2000000000

class UnitType(Enum):
    """Every unit type."""
    AI = 0
    Tech = 1
    Virus = 2
    Program = 3
    Firewall = 4

class MovementDirection(Enum):
    Invalid = 0
    Stay = 1
    Up = 2
    Down = 3
    Right = 4
    Left = 5


class Player(Enum):
    """The 2 players."""
    Attacker = 0
    Defender = 1

    def next(self) -> Player:
        """The next (other) player."""
        if self is Player.Attacker:
            return Player.Defender
        else:
            return Player.Attacker
        
    def current(self) -> Player:
        if self is Player.Attacker:
            return Player.Attacker
        else:
            return Player.Defender

class GameType(Enum):
    AttackerVsDefender = 0
    AttackerVsComp = 1
    CompVsDefender = 2
    CompVsComp = 3

##############################################################################################################

@dataclass(slots=True)
class Unit:
    player: Player = Player.Attacker
    type: UnitType = UnitType.Program
    health : int = 9
    # class variable: damage table for units (based on the unit type constants in order)
    damage_table : ClassVar[list[list[int]]] = [
        [3,3,3,3,1], # AI
        [1,1,6,1,1], # Tech
        [9,6,1,6,1], # Virus
        [3,3,3,3,1], # Program
        [1,1,1,1,1], # Firewall
    ]
    # class variable: repair table for units (based on the unit type constants in order)
    repair_table : ClassVar[list[list[int]]] = [
        [0,1,1,0,0], # AI
        [3,0,0,3,3], # Tech
        [0,0,0,0,0], # Virus
        [0,0,0,0,0], # Program
        [0,0,0,0,0], # Firewall
    ]

    def is_alive(self) -> bool:
        """Are we alive ?"""
        return self.health > 0

    def mod_health(self, health_delta : int):
        """Modify this unit's health by delta amount."""
        self.health += health_delta
        if self.health < 0:
            self.health = 0
        elif self.health > 9:
            self.health = 9

    def to_string(self) -> str:
        """Text representation of this unit."""
        p = self.player.name.lower()[0]
        t = self.type.name.upper()[0]
        return f"{p}{t}{self.health}"
    
    def __str__(self) -> str:
        """Text representation of this unit."""
        return self.to_string()
    
    def damage_amount(self, target: Unit) -> int:
        """How much can this unit damage another unit."""
        amount = self.damage_table[self.type.value][target.type.value]
        if target.health - amount < 0:
            return target.health
        return amount

    def repair_amount(self, target: Unit) -> int:
        """How much can this unit repair another unit."""
        amount = self.repair_table[self.type.value][target.type.value]
        if target.health + amount > 9:
            return 9 - target.health
        return amount

##############################################################################################################

@dataclass(slots=True)
class Coord:
    """Representation of a game cell coordinate (row, col)."""
    row : int = 0
    col : int = 0

    def col_string(self) -> str:
        """Text representation of this Coord's column."""
        coord_char = '?'
        if self.col < 16:
                coord_char = "0123456789abcdef"[self.col]
        return str(coord_char)

    def row_string(self) -> str:
        """Text representation of this Coord's row."""
        coord_char = '?'
        if self.row < 26:
                coord_char = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[self.row]
        return str(coord_char)

    def to_string(self) -> str:
        """Text representation of this Coord."""
        return self.row_string()+self.col_string()
    
    def __str__(self) -> str:
        """Text representation of this Coord."""
        return self.to_string()
    
    def clone(self) -> Coord:
        """Clone a Coord."""
        return copy.copy(self)

    def iter_range(self, dist: int) -> Iterable[Coord]:
        """Iterates over Coords inside a rectangle centered on our Coord."""
        for row in range(self.row-dist,self.row+1+dist):
            for col in range(self.col-dist,self.col+1+dist):
                yield Coord(row,col)

    def iter_adjacent(self) -> Iterable[Coord]:
        """Iterates over adjacent Coords."""
        yield Coord(self.row-1,self.col)
        yield Coord(self.row,self.col-1)
        yield Coord(self.row+1,self.col)
        yield Coord(self.row,self.col+1)

    @classmethod
    def from_string(cls, s : str) -> Coord | None:
        """Create a Coord from a string. ex: D2."""
        s = s.strip()
        for sep in " ,.:;-_":
                s = s.replace(sep, "")
        if (len(s) == 2):
            coord = Coord()
            coord.row = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".find(s[0:1].upper())
            coord.col = "0123456789abcdef".find(s[1:2].lower())
            return coord
        else:
            return None

##############################################################################################################

@dataclass(slots=True)
class CoordPair:
    """Representation of a game move or a rectangular area via 2 Coords."""
    src : Coord = field(default_factory=Coord)
    dst : Coord = field(default_factory=Coord)

    def to_string(self) -> str:
        """Text representation of a CoordPair."""
        return self.src.to_string()+" "+self.dst.to_string()
    
    def __str__(self) -> str:
        """Text representation of a CoordPair."""
        return self.to_string()

    def clone(self) -> CoordPair:
        """Clones a CoordPair."""
        return copy.copy(self)

    def iter_rectangle(self) -> Iterable[Coord]:
        """Iterates over cells of a rectangular area."""
        for row in range(self.src.row,self.dst.row+1):
            for col in range(self.src.col,self.dst.col+1):
                yield Coord(row,col)

    @classmethod
    def from_quad(cls, row0: int, col0: int, row1: int, col1: int) -> CoordPair:
        """Create a CoordPair from 4 integers."""
        return CoordPair(Coord(row0,col0),Coord(row1,col1))
    
    @classmethod
    def from_dim(cls, dim: int) -> CoordPair:
        """Create a CoordPair based on a dim-sized rectangle."""
        return CoordPair(Coord(0,0),Coord(dim-1,dim-1))
    
    @classmethod
    def from_string(cls, s : str) -> CoordPair | None:
        """Create a CoordPair from a string. ex: A3 B2"""
        s = s.strip()
        for sep in " ,.:;-_":
                s = s.replace(sep, "")
        if (len(s) == 4):
            coords = CoordPair()
            coords.src.row = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".find(s[0:1].upper())
            coords.src.col = "0123456789abcdef".find(s[1:2].lower())
            coords.dst.row = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".find(s[2:3].upper())
            coords.dst.col = "0123456789abcdef".find(s[3:4].lower())
            return coords
        else:
            return None

##############################################################################################################

@dataclass(slots=True)
class Options:
    """Representation of the game options."""
    dim: int = 5
    max_depth : int | None = 4
    min_depth : int | None = 2
    max_time : float | None = 5.0
    game_type : GameType = GameType.AttackerVsDefender
    alpha_beta : bool = True
    max_turns : int | None = 100
    randomize_moves : bool = True
    broker : str | None = None
    heuristic_name: str | None = None  

##############################################################################################################

@dataclass(slots=True)
class Stats:
    """Representation of the global game statistics."""
    evaluations_per_depth : dict[int,int] = field(default_factory=dict)
    total_seconds: float = 0.0
    cumulative_evals: int = 0
    evals_by_depth: Dict[int, int] = field(default_factory=dict)

    def update_cumulative_evals(self, depth: int, evals: int):
        self.cumulative_evals += evals
        self.evals_by_depth[depth] = self.evals_by_depth.get(depth, 0) + evals

    def get_percentage_evals_by_depth(self):
        total_evals = self.cumulative_evals
        percentages = {}
        for depth, evals in self.evals_by_depth.items():
            percentages[depth] = (evals / total_evals) * 100
        return percentages
    
##############################################################################################################

def get_initial_board_configuration(game):
    dim = game.options.dim
    initial_board = ""
    for row in range(dim):
     for col in range(dim):
            unit = game.get(Coord(row, col))
            if unit is None:
                initial_board += "."
            else:
                initial_board += str(unit)
    return initial_board


##############################################################################################################

class AIPlayer:
    def __init__(self, heuristic_function, max_depth, timeout, max_turns, alpha_beta, play_mode, heuristic_name):
        self.heuristic_function = heuristic_function
        self.max_depth = max_depth
        self.timeout = timeout
        self.max_turns = max_turns
        self.alpha_beta = alpha_beta
        self.play_mode = play_mode
        self.heuristic_name = heuristic_name
       
    

##############################################################################################################

@dataclass(slots=True)
class Game:
    """Representation of the game state."""
    board: list[list[Unit | None]] = field(default_factory=list)
    next_player: Player = Player.Attacker
    turns_played : int = 0
    options: Options = field(default_factory=Options)
    stats: Stats = field(default_factory=Stats)
    _attacker_has_ai : bool = True
    _defender_has_ai : bool = True
    move_performed : str = ""
    move_coordinates : CoordPair | None = None
    initial_board_configuration: str = ""  # Define initial_board_configuration as a class attribute

    def __post_init__(self):
        """Automatically called after class init to set up the default board state."""
        dim = self.options.dim
        self.board = [[None for _ in range(dim)] for _ in range(dim)]
        md = dim-1
        self.set(Coord(0,0),Unit(player=Player.Defender,type=UnitType.AI))
        self.set(Coord(1,0),Unit(player=Player.Defender,type=UnitType.Tech))
        self.set(Coord(0,1),Unit(player=Player.Defender,type=UnitType.Tech))
        self.set(Coord(2,0),Unit(player=Player.Defender,type=UnitType.Firewall))
        self.set(Coord(0,2),Unit(player=Player.Defender,type=UnitType.Firewall))
        self.set(Coord(1,1),Unit(player=Player.Defender,type=UnitType.Program))
        self.set(Coord(md,md),Unit(player=Player.Attacker,type=UnitType.AI))
        self.set(Coord(md-1,md),Unit(player=Player.Attacker,type=UnitType.Virus))
        self.set(Coord(md,md-1),Unit(player=Player.Attacker,type=UnitType.Virus))
        self.set(Coord(md-2,md),Unit(player=Player.Attacker,type=UnitType.Program))
        self.set(Coord(md,md-2),Unit(player=Player.Attacker,type=UnitType.Program))
        self.set(Coord(md-1,md-1),Unit(player=Player.Attacker,type=UnitType.Firewall))

        # Generate the initial board configuration and store it in an instance variable
        self.initial_board_configuration = get_initial_board_configuration(self)

    def clone(self) -> Game:
        """Make a new copy of a game for minimax recursion.

        Shallow copy of everything except the board (options and stats are shared).
        """
        new = copy.copy(self)
        new.board = copy.deepcopy(self.board)
        return new

    def is_empty(self, coord : Coord) -> bool:
        """Check if contents of a board cell of the game at Coord is empty (must be valid coord)."""
        return self.board[coord.row][coord.col] is None

    def get(self, coord : Coord) -> Unit | None:
        """Get contents of a board cell of the game at Coord."""
        if self.is_valid_coord(coord):
            return self.board[coord.row][coord.col]
        else:
            return None

    def set(self, coord : Coord, unit : Unit | None):
        """Set contents of a board cell of the game at Coord."""
        if self.is_valid_coord(coord):
            self.board[coord.row][coord.col] = unit

    def remove_dead(self, coord: Coord):
        """Remove unit at Coord if dead."""
        unit = self.get(coord)
        if unit is not None and not unit.is_alive():
            self.set(coord,None)
            if unit.type == UnitType.AI:
                if unit.player == Player.Attacker:
                    self._attacker_has_ai = False
                else:
                    self._defender_has_ai = False

    def mod_health(self, coord : Coord, health_delta : int):
        """Modify health of unit at Coord (positive or negative delta)."""
        target = self.get(coord)
        if target is not None:
            target.mod_health(health_delta)
            self.remove_dead(coord)

    def is_valid_move(self, coords : CoordPair) -> bool:
        """Validate a move expressed as a CoordPair."""

        # validate coordinates
        if not self.is_valid_coord(coords.src) or not self.is_valid_coord(coords.dst):
            return False

        # check if a valid unit was selected (player or opponent)
        attacking_unit = self.get(coords.src)
        if attacking_unit is None or attacking_unit.player != self.next_player:
            return False

        defending_unit = self.get(coords.dst)

        # self destruct
        if attacking_unit == defending_unit:
            return True

        # move onto another unit
        elif defending_unit is not None:
            # any adversary units can attack each other
            if attacking_unit.to_string()[0] != defending_unit.to_string()[0]:
                return True
            # unit can only do a repair movement if it has an effect
            else:
                if(attacking_unit.repair_amount(defending_unit)>0):
                    return True
                return False

        # moving onto empty spot
        elif defending_unit is None and self.validate_movement_direction(coords, attacking_unit):

            # if the moving unit is an AI, a Firewall or a Program, make sure it isn't in combat
            if attacking_unit.to_string()[1] == 'A' or attacking_unit.to_string()[1] == 'F' or attacking_unit.to_string()[1] == 'P':
                if self.is_engaged_in_combat(coords.src, attacking_unit):
                    return False

            return True
        
        return False

    def is_engaged_in_combat(self, src_coord: Coord, unit: UnitType) -> bool:

        current_player: str = unit.to_string()[0]
        if current_player == 'a':
            enemy_player = 'd'
        else:
            enemy_player = 'a'

        # make sure there are no enemies around the player
        adjacent_spots = src_coord.iter_adjacent()
        for i in adjacent_spots:
            adjacent_unit = self.get(i)
            if adjacent_unit is not None and adjacent_unit.to_string()[0] == enemy_player:
                return True
        return False

    def validate_movement_direction(self, coords: CoordPair, unit: UnitType):
        """Check if a player's chosen direction is compatible with the unit being used"""

        direction: str = self.get_movement_direction(coords)

        if direction == MovementDirection.Invalid:
            return False

        if direction == MovementDirection.Stay:
            return True

        if unit.to_string()[0] == 'a':
            if unit.to_string()[1] == 'A' or unit.to_string()[1] == 'F' or unit.to_string()[1] == 'P':
                if direction == MovementDirection.Left or direction == MovementDirection.Up:
                    return True
                else:
                    return False
            return True
        else:
            if unit.to_string()[1] == 'A' or unit.to_string()[1] == 'F' or unit.to_string()[1] == 'P':
                if direction == MovementDirection.Right or direction == MovementDirection.Down:
                    return True
                else:
                    return False
            return True


    def get_movement_direction(self, coords : CoordPair) -> MovementDirection:
        """Check what direction the coordinate pair is moving"""

        src_coord = coords.src.to_string()
        dst_coord = coords.dst.to_string()

        # 'moving' to the same spot is valid for self-destruction
        if src_coord == dst_coord:
            return MovementDirection.Stay

        # horizontal movement
        elif src_coord[0] == dst_coord[0]:
            if int(src_coord[1]) + 1 == int(dst_coord[1]):
                return MovementDirection.Right
            elif int(src_coord[1]) - 1 == int(dst_coord[1]):
                return MovementDirection.Left
            return MovementDirection.Invalid

        # vertical movement
        elif src_coord[1] == dst_coord[1]:
            if ord(src_coord[0]) + 1 == ord(dst_coord[0]):
                return MovementDirection.Down
            elif ord(src_coord[0]) - 1 == ord(dst_coord[0]):
                return MovementDirection.Up
            return MovementDirection.Invalid

        return MovementDirection.Invalid

            

    def perform_move(self, coords : CoordPair) -> Tuple[bool,str]:
        """Validate and perform a move expressed as a CoordPair. """
        if self.is_valid_move(coords):
            # Let a unit attack, repair another unit or self-destruct
            if(self.get(coords.dst) is not None):
                # unit self-destructs
                if(self.get(coords.src)==self.get(coords.dst)):
                    self.move_performed="self destruct"
                    self.self_destruct(coords.src)
                    return (True,"")
                    # a unit attacks another unit
                elif(self.get(coords.dst).to_string()[0]!=self.get(coords.src).to_string()[0]):
                    if(self.get(coords.src).is_alive and self.get(coords.dst).is_alive):
                        self.attack_unit(coords)
                        return (True,"")
                    # a unit repairs another unit
                elif(self.get(coords.dst).to_string()[0]==self.get(coords.src).to_string()[0]):
                    if(self.get(coords.src).is_alive and self.get(coords.dst).is_alive):
                        self.repair_unit(coords)
                        return (True,"")
              #unit goes to empty adjacent coordinate      
            elif(self.get(coords.dst) is None):
                self.move_performed="moved to"
                self.set(coords.dst,self.get(coords.src))
                self.set(coords.src,None)
                return (True,"")
        return (False,"invalid move")
    
    def self_destruct(self,coord: Coord):
        coordinates=coord.iter_range(1)
        for adjCoord in coordinates:
            if self.is_valid_coord(adjCoord):
                unit_at_adj= self.get(adjCoord)
                if unit_at_adj is not None:
                    unit_at_adj.mod_health(-2)
                    if not unit_at_adj.is_alive():
                        self.remove_dead(adjCoord)
        self.get(coord).mod_health(-9)
        self.remove_dead(coord)

    def attack_unit(self,coords:CoordPair):
        self.move_performed="attacked"
        damageAmount=self.get(coords.src).damage_amount(self.get(coords.dst))
        self.get(coords.src).mod_health(-damageAmount)
        self.get(coords.dst).mod_health(-damageAmount)
        #remove unit if health reaches 0
        if(self.get(coords.src).health==0):
            self.remove_dead(coords.src)
        if(self.get(coords.dst).health==0):
            self.remove_dead(coords.dst)

    def repair_unit(self,coords:CoordPair):
        self.move_performed="repaired"
        if(self.get(coords.src).health>self.get(coords.dst).health):
            repairAmount=self.get(coords.src).repair_amount(self.get(coords.dst))
            self.get(coords.dst).mod_health(repairAmount)

    def next_turn(self):
        """Transitions game to the next turn."""
        self.next_player = self.next_player.next()
        self.turns_played += 1

    def to_string(self) -> str:
        """Pretty text representation of the game."""
        dim = self.options.dim
        output = ""
        output += f"Next player: {self.next_player.name}\n"
        output += f"Turns played: {self.turns_played}\n"
        coord = Coord()
        output += "\n   "
        for col in range(dim):
            coord.col = col
            label = coord.col_string()
            output += f"{label:^3} "
        output += "\n"
        for row in range(dim):
            coord.row = row
            label = coord.row_string()
            output += f"{label}: "
            for col in range(dim):
                coord.col = col
                unit = self.get(coord)
                if unit is None:
                    output += " .  "
                else:
                    output += f"{str(unit):^3} "
            output += "\n"
        return output

    def __str__(self) -> str:
        """Default string representation of a game."""
        return self.to_string()
    
    def is_valid_coord(self, coord: Coord) -> bool:
        """Check if a Coord is valid within out board dimensions."""
        dim = self.options.dim
        if coord.row < 0 or coord.row >= dim or coord.col < 0 or coord.col >= dim:
            return False
        return True

    def read_move(self) -> CoordPair:
        """Read a move from keyboard and return as a CoordPair."""
        while True:
            s = input(F'Player {self.next_player.name}, enter your move: ')
            coords = CoordPair.from_string(s)
            if coords is not None and self.is_valid_coord(coords.src) and self.is_valid_coord(coords.dst):
                return coords
            else:
                print('Invalid coordinates! Try again.')
    
    def human_turn(self):
        """Human player plays a move (or get via broker)."""
        if self.options.broker is not None:
            print("Getting next move with auto-retry from game broker...")
            while True:
                mv = self.get_move_from_broker()
                if mv is not None:
                    (success,result) = self.perform_move(mv)
                    print(f"Broker {self.next_player.name}: ",end='')
                    print(result)
                    if success:
                        self.next_turn()
                        self.move_coordinates=mv
                        break
                sleep(0.1)
        else:
            while True:
                mv = self.read_move()
                (success,result) = self.perform_move(mv)
                if success:
                    print(f"Player {self.next_player.name}: ",end='')
                    print(result)
                    self.next_turn()
                    self.move_coordinates=mv
                    break
                else:
                    print("The move is not valid! Try again.")

    def computer_turn(self) -> CoordPair | None:
        """Computer plays a move."""
        mv = self.suggest_move()
        if mv is not None:
            (success,result) = self.perform_move(mv)
            if success:
                print(f"Computer {self.next_player.name}: ",end='')
                print(result)
                self.next_turn()
        return mv

    def player_units(self, player: Player) -> Iterable[Tuple[Coord,Unit]]:
        """Iterates over all units belonging to a player."""
        for coord in CoordPair.from_dim(self.options.dim).iter_rectangle():
            unit = self.get(coord)
            if unit is not None and unit.player == player:
                yield (coord,unit)

    def is_finished(self) -> bool:
        """Check if the game is over."""
        return self.has_winner() is not None

    def has_winner(self) -> Player | None:
        """Check if the game is over and returns winner"""
        if self.options.max_turns is not None and self.turns_played >= self.options.max_turns:
            return Player.Defender
        elif self._attacker_has_ai:
            if self._defender_has_ai:
                return None
            else:
                return Player.Attacker    
        elif self._defender_has_ai:
            return Player.Defender

    def move_candidates(self) -> Iterable[CoordPair]:
        """Generate valid move candidates for the next player."""
        move = CoordPair()
        for (src,_) in self.player_units(self.next_player):
            move.src = src
            for dst in src.iter_adjacent():
                move.dst = dst
                if self.is_valid_move(move):
                    yield move.clone()
            move.dst = src
            yield move.clone()
    
    def move_candidates_current_player(self) -> Iterable[CoordPair]:
        """Generate valid move candidates for the next player."""
        move = CoordPair()
        for (src,_) in self.player_units:
            move.src = src
            for dst in src.iter_adjacent():
                move.dst = dst
                if self.is_valid_move(move):
                    yield move.clone()
            move.dst = src
            yield move.clone()

    def random_move(self) -> Tuple[int, CoordPair | None, float, int]:
        """Returns a random move."""
        evals = 0 
        move_candidates = list(self.move_candidates())
        random.shuffle(move_candidates)
        if len(move_candidates) > 0:
            return (0, move_candidates[0], 1, 1)
        else:
            return (0, move_candidates[0], 1, evals)

    def suggest_move(self) -> CoordPair | None:
        """Suggest the next move using minimax alpha beta. TODO: REPLACE RANDOM_MOVE WITH PROPER GAME LOGIC!!!"""
        start_time = datetime.now()

        (score, move, avg_depth, evals) = self.random_move()

        if self.next_player == Player.Attacker:
            self.min_value(0, -100000, 100000, {})
        else:
            self.max_value(0, -100000, 100000, {})

        elapsed_seconds = (datetime.now() - start_time).total_seconds()
        self.stats.total_seconds += elapsed_seconds
        self.stats.update_cumulative_evals(avg_depth, evals)  # Update cumulative evals
        percentages = self.stats.get_percentage_evals_by_depth()  # Get percentage evals by depth
        branching_factor = evals / max(1, self.turns_played)  # Calculate branching factor
        print(f"Turn #{self.turns_played}")
        print(f"Player {self.next_player.name}:", end=' ')
        print(f"Action: {move}" if move else "No valid moves")
        print(f"Time for this action: {elapsed_seconds:.2f} sec")
        print(f"Heuristic score: {score}")
        print(f"New Configuration:")
        print(self)
        print(f"Cumulative evals: {self.stats.cumulative_evals/1e6:.2f}M")
        print(f"Cumulative evals by depth:", end=' ')
        for depth, depth_evals in self.stats.evals_by_depth.items():
         print(f"{depth}={depth_evals}", end=' ')
        print()
        print(f"Cumulative % evals by depth:", end=' ')
        for depth, percentage in percentages.items():
         print(f"{depth}={percentage:.1f}%", end=' ')
        print()
        print(f"Average branching factor: {branching_factor:.1f}")
        return move

    # TODO: include max depth. I'm currently just making it 4
    # TODO: evaluate heuristic value at node
    # TODO: use the game configurations to check if alpha-beta is on
    # TODO: save the current move
    def max_value(self, depth, alpha, beta, all_values: dict):
         

        if depth == self.max_depth:
            value = self.heuristic_function()  # Calculate the heuristic value
            all_values['node'] = value
            return value
         
        if depth == 4:
            value = self.get_random_heuristic_value()
            all_values['node'] = value
            return value

        all_values['nodes'] = []    # TODO: remove

        value = -100000

        move_candidate = self.move_candidates()
        for move in move_candidate:

            new_node: dict = {}     # TODO: remove
            all_values['nodes'].append(new_node)    # TODO: remove

            new_game = self.clone()
            new_game.perform_move(move)
            new_value = new_game.min_value(depth+1, alpha, beta, new_node)  # TODO: remove new node
            if new_value > value:
                value = new_value
                # save the move
            # if alpha-beta pruning is on:
            if new_value >= beta:
                break
            if new_value > alpha:
                alpha = new_value

        if depth == 0:
            with open("json_dump.jso", 'w') as json_file:
                json.dump(all_values, json_file, indent=4)
                print('done')

        all_values[value] = all_values['nodes'] # TODO: remove
        del all_values['nodes'] # TODO: remove

        return 0

    def min_value(self, depth, alpha, beta, all_values: dict):

        if depth == self.max_depth:
            value = self.heuristic_function()  # Calculate the heuristic value
            all_values['node'] = value
            return value
        
        if depth == 4:
            value = self.get_heuristic_e0
            print('node value: ' + value)
            return value

        all_values['nodes'] = []    # TODO: remove

        value = 100000

        move_candidate = self.move_candidates()
        for move in move_candidate:

            new_node: dict = {}     # TODO: remove
            all_values['nodes'].append(new_node)    # TODO: remove

            new_game = self.clone()
            new_game.perform_move(move)
            new_value = new_game.max_value(depth + 1, alpha, beta, new_node)    # TODO: remove new node
            if new_value < value:
                value = new_value
                # save the move
            # if alpha-beta pruning is on:
            if new_value <= alpha:
                break
            if new_value < beta:
                beta = new_value

        all_values[value] = all_values['nodes']  # TODO: remove
        del all_values['nodes']  # TODO: remove

        return value
    
    def get_heuristic_e0(self) -> int:
        #e0 = (3VP1 + 3TP1 + 3FP1 + 3PP1 + 9999AIP1) − (3VP2 + 3TP2 + 3FP2 + 3PP2 + 9999AIP2)
        player_1_units=self.player_units
        player_2_units=self.player_units(self.next_player)

        countV1=0
        countV2=0
        countT1=0
        countT2=0
        countF1=0
        countF2=0
        countP1=0
        countP2=0
        countAI1=0
        countAI2=0

        for unit in player_1_units:
            match unit.to_string()[1]:
                case "V":
                    countV1+=1
                case "T":
                    countT1+=1
                case "F":
                    countF1+=1
                case "P":
                    countP1+=1
                case "A":
                    countAI1+=1
        
        for unit in player_2_units:
            match unit.to_string()[1]:
                case "V":
                    countV2+=1
                case "T":
                    countT2+=1
                case "F":
                    countF2+=1
                case "P":
                    countP2+=1
                case "A":
                    countAI2+=1

        e0=(3*countV1 + 3*countT1 + 3*countF1 + 3*countP1 + 9999*countAI1) - (3*countV2 + 3*countT2 + 3*countF2 + 3*countP2 + 9999*countAI2)
        return e0

    def get_heuristic_e1(self) -> int:
        #e1=(nb of moves available for player 1) - (nb of moves avaliable for player 2)

        moves_player_1=self.move_candidates_current_player
        moves_player_2=self.move_candidates

        count_moves_player_1=0
        count_moves_player_2=0

        for move in moves_player_1:
            count_moves_player_1+=1
        
        for move in moves_player_2:
            count_moves_player_2+=1
        
        e1=count_moves_player_1-moves_player_2
        return e1
        
        

    # this is just a placeholder until I have the real heuristic functions
    @staticmethod
    def get_random_heuristic_value():
        return random.randint(0, 10000)


    def post_move_to_broker(self, move: CoordPair):
        """Send a move to the game broker."""
        if self.options.broker is None:
            return
        data = {
            "from": {"row": move.src.row, "col": move.src.col},
            "to": {"row": move.dst.row, "col": move.dst.col},
            "turn": self.turns_played
        }
        try:
            r = requests.post(self.options.broker, json=data)
            if r.status_code == 200 and r.json()['success'] and r.json()['data'] == data:
                # print(f"Sent move to broker: {move}")
                pass
            else:
                print(f"Broker error: status code: {r.status_code}, response: {r.json()}")
        except Exception as error:
            print(f"Broker error: {error}")

    def get_move_from_broker(self) -> CoordPair | None:
        """Get a move from the game broker."""
        if self.options.broker is None:
            return None
        headers = {'Accept': 'application/json'}
        try:
            r = requests.get(self.options.broker, headers=headers)
            if r.status_code == 200 and r.json()['success']:
                data = r.json()['data']
                if data is not None:
                    if data['turn'] == self.turns_played+1:
                        move = CoordPair(
                            Coord(data['from']['row'],data['from']['col']),
                            Coord(data['to']['row'],data['to']['col'])
                        )
                        print(f"Got move from broker: {move}")
                        return move
                    else:
                        # print("Got broker data for wrong turn.")
                        # print(f"Wanted {self.turns_played+1}, got {data['turn']}")
                        pass
                else:
                    # print("Got no data from broker")
                    pass
            else:
                print(f"Broker error: status code: {r.status_code}, response: {r.json()}")
        except Exception as error:
            print(f"Broker error: {error}")
        return None

##############################################################################################################

cumulative_info = {}
def print_cumulative_info(player):
    print(f"Cumulative Information (Player {player.name} - {'AI' if player != Player.AttackerVsDefender else 'H'}):")
    print(f"Cumulative Evals: {cumulative_info[player]['Cumulative Evals']/1e6:.2f}M")
    print(f"Cumulative Evals by Depth:", end=' ')
    for depth, depth_evals in cumulative_info[player]["Cumulative Evals by Depth"].items():
        print(f"{depth}={depth_evals}", end=' ')
    print()
    print(f"Cumulative % Evals by Depth:", end=' ')
    for depth, percentage in cumulative_info[player]["Cumulative % Evals by Depth"].items():
        print(f"{depth}={percentage:.1f}%", end=' ')
    print()
    print(f"Average Branching Factor: {cumulative_info[player]['Average Branching Factor']:.1f}")

    

def main():

    # parse command line arguments
    parser = argparse.ArgumentParser(
        prog='ai_wargame',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--heuristic', type=str, choices=['e0', 'e1', 'e2'], help='Select the heuristic function (e0, e1, e2)')
    parser.add_argument('--max_depth', type=int, help='maximum search depth')
    parser.add_argument('--max_time', type=float, help='maximum search time')
    parser.add_argument('--game_type', type=str, default="attacker", help='game type: auto|attacker|defender|manual')
    parser.add_argument('--alpha_beta', action='store_true', help='Enable alpha-beta pruning')
    parser.add_argument('--broker', type=str, help='play via a game broker')
    args = parser.parse_args()



    # parse the game type
    if args.game_type == "attacker":
        game_type = GameType.AttackerVsComp
    elif args.game_type == "defender":
        game_type = GameType.CompVsDefender
    elif args.game_type == "manual":
        game_type = GameType.AttackerVsDefender
    else:
        game_type = GameType.CompVsComp

 

  # Create a dictionary to store cumulative information for each player
    cumulative_info = {
        Player.Attacker: {
            "Cumulative Evals": 0,
            "Cumulative Evals by Depth": {},
            "Cumulative % Evals by Depth": {},
            "Average Branching Factor": 0.0,
        },
        Player.Defender: {
            "Cumulative Evals": 0,
            "Cumulative Evals by Depth": {},
            "Cumulative % Evals by Depth": {},
            "Average Branching Factor": 0.0,
        },
    }
    # set up game options
    options = Options(game_type=game_type)

    # override class defaults via command line options
    if args.max_depth is not None:
        options.max_depth = args.max_depth
    if args.max_time is not None:
        options.max_time = args.max_time
    if args.broker is not None:
        options.broker = args.broker


# create a new game

    game = Game(options=options)

# Track game parameters
    is_alpha_beta = "true" if options.alpha_beta else "false"

    timeoutInput=input("What maximum amount of time would you like?") #not gonna use it for D1
    timeout = str(options.max_time)
    
    options.max_turns=int(input("What is the maximum number of turns you want? \n"))
    max_turns = str(options.max_turns)

    # Generate the output file name
    output_file_name = f"gameTrace-{is_alpha_beta}-{timeout}-{max_turns}.txt"

    # Open the output file for writing
    with open(output_file_name, "w") as output_file:

        # Write game parameters to the output file
        output_file.write(f"Timeout (seconds): {timeout}\n")
        output_file.write(f"Max Turns: {max_turns}\n")
        output_file.write(f"Alpha-Beta: {is_alpha_beta}\n")
        output_file.write(f"Player 1: {'AI' if game_type != GameType.AttackerVsDefender else 'H'}\n")
        output_file.write(f"Player 2: {'AI' if game_type != GameType.AttackerVsDefender else 'H'}\n")
        output_file.write("\nInitial Configuration:\n")
        # Write the initial board configuration to the output file
        output_file.write(str(game))



    
    # the main game loop
    while True:
        print()
        print(game)
        winner = game.has_winner()
        if winner is not None:
            print("The winner is "+winner.name+ " in "+str(game.turns_played)+ " turns!")
            with open(output_file_name, "a") as output_file:
                output_file.write("\n"+f"{winner.name} wins in "+ str(game.turns_played)+ " turns!")
            break
        if game.options.game_type == GameType.AttackerVsDefender:
            game.human_turn()
        if game.move_coordinates is not None:
            # Check if the human's move is valid
            if not game.is_valid_move(game.move_coordinates):
                print("Invalid move. The AI wins.")
                winner = Player.AI  # Award victory to AI
                break
            else:
                action_description = "Move not valid"
            with open(output_file_name, "a") as output_file:
                output_file.write(f"Turn #{game.turns_played}\n")
                if(game.next_player.name=="Attacker"):
                    output_file.write(f"Player Defender: Action: {action_description}\n")
                else:
                    output_file.write(f"Player Attacker: Action: {action_description}\n")
            with open(output_file_name, "a") as output_file:
                output_file.write("New Configuration:\n")
                output_file.write(str(game)) 

        elif game.options.game_type == GameType.AttackerVsComp and game.next_player == Player.Attacker:
            game.human_turn()
        elif game.options.game_type == GameType.CompVsDefender and game.next_player == Player.Defender:
            game.human_turn()
        else:
            player = game.next_player
            move = game.computer_turn()


        # Check if the AI's move is valid
        if not game.is_valid_move(move):
            print("Invalid move. The human wins.")
            winner = Player.Human  # Award victory to the human
            break

        if winner is not None:
           print(f"The winner is {winner.name}!")
        else:
           print("It's a draw!")


    heuristic_function = None
    if args.heuristic == 'e0':
        heuristic_function = AIPlayer.get_heuristic_e0
    elif args.heuristic == 'e1':
        heuristic_function = AIPlayer.get_heuristic_e1
   

    ai_player = AIPlayer(
        heuristic_function=heuristic_function,
        max_depth=args.max_depth,
        timeout=args.max_time,
        alpha_beta=args.alpha_beta,
        play_mode="AI",
        heuristic_name=args.heuristic
    )



##############################################################################################################

if __name__ == '__main__':
       game = main()
